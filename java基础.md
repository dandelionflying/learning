#### 1、位运算

| 按位与                     | 按位或                         | 按位取反      | 按位异或                        |
| -------------------------- | ------------------------------ | ------------- | ------------------------------- |
| 0&0=0; 0&1=0; 1&0=0; 1&1=1 | 0\|0=0；0\|1=1；1\|0=1；1\|1=1 | ~1=0； ~0=1； | 0^0=0； 0^1=1； 1^0=1； 1^1=0； |
| 都为1才是1                 | 有1就是1                       |               | 相同为0，不同为1                |

#### 2、switch支持的类型

Incompatible types. Found: 'float', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum

#### 3、用最有效率的方法算出2乘以8等於几?

2<< 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，直接cpu计算，最快。

#### 4、使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

#### 5、list遍历方式选择

实现了RandomAccess接口的list，优先选择for循环，其次foreach

未实现RandomAccess接口的list，优先选择iterator遍历，大size的数据不要使用for循环

#### 6、HashMap与HashTable的区别？

线程安全性？

效率？

null key？

初始容纳量大小不同？每次扩充大小不同？

​	hashtable初始11每次扩充为2n+1，hashmap初始16每次扩充为2n。

​	创建时给定初始值，hashtable使用该值，hashmap扩充至2的幂次方（**为了减少碰撞**）。

底层数据结构

​	当hashmap链表大于阈值（8），链表转化为红黑树

#### 7、hashmap死循环问题？（待看）

#### 8、哈希冲突？

即k1!=k2，但哈希函数计算出的哈希值相等calhash(k1) = calhash(k2)，导致哈希冲突。

#### 9、ConcurrentHashMap 和hashtable 区别？

线程安全方式：**jdk1.7时**，concurrenthashmap使用**分段锁**，每一把锁只锁容器其中一部分数据，多线程访问容器里的不同数据段的数据，不存在锁竞争，提高并发访问率。**jdk1.8后**，采用**CAS（乐观锁）和synchronized**来保证并发安全  ，**node数组+链表+红黑树**，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发  。

hashtable使用**同一把锁**，例如，使用put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。