#### 1、位运算

| 按位与                     | 按位或                         | 按位取反      | 按位异或                        |
| -------------------------- | ------------------------------ | ------------- | ------------------------------- |
| 0&0=0; 0&1=0; 1&0=0; 1&1=1 | 0\|0=0；0\|1=1；1\|0=1；1\|1=1 | ~1=0； ~0=1； | 0^0=0； 0^1=1； 1^0=1； 1^1=0； |
| 都为1才是1                 | 有1就是1                       |               | 相同为0，不同为1                |

#### 2、switch支持的类型

Incompatible types. Found: 'float', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum

#### 3、用最有效率的方法算出2乘以8等於几?

2<< 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，直接cpu计算，最快。

#### 4、使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

#### 5、list遍历方式选择

实现了RandomAccess接口的list，优先选择for循环，其次foreach

未实现RandomAccess接口的list，优先选择iterator遍历，大size的数据不要使用for循环

#### 6、HashMap与HashTable的区别？

线程安全性？

效率？

null key？

初始容纳量大小不同？每次扩充大小不同？

​	hashtable初始11每次扩充为2n+1，hashmap初始16每次扩充为2n。

​	创建时给定初始值，hashtable使用该值，hashmap扩充至2的幂次方（**为了减少碰撞**）。

底层数据结构

​	当hashmap链表大于阈值（8），链表转化为红黑树

https://zhuanlan.zhihu.com/p/21673805

#### 7、hashmap死循环问题？（待看）

#### 8、哈希冲突？

即k1!=k2，但哈希函数计算出的哈希值相等calhash(k1) = calhash(k2)，导致哈希冲突。

#### 9、ConcurrentHashMap 和hashtable 区别？

线程安全方式：**jdk1.7时**，concurrenthashmap使用**分段锁**，每一把锁只锁容器其中一部分数据，多线程访问容器里的不同数据段的数据，不存在锁竞争，提高并发访问率。**jdk1.8后**，采用**CAS（乐观锁）和synchronized**来保证并发安全  ，**node数组+链表+红黑树**，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发  。

hashtable使用**同一把锁**，例如，使用put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

#### 10、synchronized

加到非static方法上是给对象实例加锁

static方法：类锁住

代码块synchronized（this）：对象锁住

代码块synchronized（class）：类锁住

#### 11、 指令重排问题

> 需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。
> uniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton()`; 这段代码其实是分为三步执行
>
> 为 uniqueInstance 分配内存空间、初始化 uniqueInstance、将 uniqueInstance 指向分配的内存地址
> 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用
> getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。
> 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。  

#### 12、synchronized和ReenTrantLock区别

都是可重入锁

synchronized依赖于jvm，ReenTrantLock依赖于API（需要使用lock(),unlock(),tryfinally）

ReenTrantLock可指定是公平锁还是非公平锁（构造函数可配置）

> volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从**主存**中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

#### 13、volatile  

禁止jvm指令重排

volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从**主存**中读取；

#### 14、synchronized、volatile区别

volatile只能作用于变量

volatile主要用于解决变量在多个线程之间的可见性，synchronized解决多个线程之间访问资源的同步性

#### 15、为什么用线程池？

降低资源消耗：重复利用已创建的线程降低创建销毁造成的消耗

提高响应速度：取出即用，不需创建

提高线程的可管理性：利于调优

#### 16、Runnable Callable区别

Runnable的run()无返回值，Callable的run()有返回值

#### 17、了解Atomic原子类吗

利用CAS（compare and swap） + volatile和native方法来保证院子操作，避免synchronized的高开销。

#### 18、了解AQS吗

ReenTrantLock就是基于AQS的，按我自己的话简单讲讲就是，假如A资源被占用了，锁住A，后续请求访问A的线程均放到队列（虚拟的双向队列，节点之间才互相关联）中去。

AQS使用一个volatile的int共享变量，保证可见。

AQS两种资源共享方式：

- 独占（ReenTrantLock）
  - 公平锁：按顺序来
  - 非公平锁：谁抢到是谁的
- 共享（CountDownLatCh ReadWriteLock  等）

#### 19、设计模式

需要写一下单例、工厂、代理、观察者

#### 20、四次挥手怎么解释？

比较通俗的类比：

> A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的
> 话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

#### 21、linux用过哪些指令？

启动服务 systemctl service start

查看cpu等信息：top

目录创建：mkdir [filename]

显示当前目录所有目录和文件：ls

移动：mv [from] [to]

复制：cp -r [from] [to]  （-r代表递归拷贝）

文件创建：touch

文件查看：cat

动态监控文件的变化：tail -f （在日志文件监控时用过）

修改文件：vim

解压： tar （可带参数：z使用gzip，c压缩/x解压，v显示过程，f指定文件名）  第二个参数可带-C指定解压位置

显示当前路径：pwd

当前进程：ps -ef

网络：ifconfig

端口使用：netstat

#### 22、mysql有哪些存储引擎？有什么区别？

Myisam（米儿sam），innodb，memory

事务上：myisam不支持，innodb支持

锁：myisam默认表锁，不支持行级锁；innodb默认行锁，可配置表级锁

外键：myisam不支持，innodb支持

侧重点：myisam侧重性能，每次查询具有原子性，速度比innodb快

选择：myisam更适合读密集，innodb适合写密集，至于实际选择，还得看实际的业务反应到数据操作上是怎样的。

**memory引擎**：数据都在内存中，每个基于memory的表实际对应一个.frm磁盘文件，该文件即表结构，数据在内存中。所以生命周期很短。默认hash索引。 **可以没用过，但一定得知道有这么个东西。**

#### 23.主键自增还是uuid？

单机数量大--自增，不多--uuid

分布式数量大（比单机意义上的大要大很多，可能是千万级别）--自增，不多--uuid

#### 24.覆盖索引怎么理解？

简单说就是  该索引涉及的列 包含 select 的所有列

innodb中除主键索引，叶子结点存储的是**主键+列值**

假如不满足，那么会回表查询，如index(name)，对于`select id,name,sex from table` 而言，name能在索引数中找得到，但sex不行，这是就会回表再查找一次，导致查询慢。

#### 25.为什么索引能提高访问速度？

底层可以根据索引列名进行二分查找，复杂度约等于 log2N

#### 26.什么是最左前缀原则？

索引建立后，做条件查询时，查询条件要从左到右按顺序匹配到索引的某一列或多列，才有命中索引。

但假如条件列与索引列完全一致，则依然可以命中，忽略条件查询的顺序。

#### 27.说一下mysql分库分表？

- 垂直分表：列的拆分。通俗讲也就是纵向切开，左边一部分列，右边一部分列，两边的数据要有各自的特征。
  - 垂直拆分使得单行数据变少，减少I/O，易于维护。
  - 但主键会冗余。会引起join操作，但join可以在java代码处理。
- 水平分表：行的拆分。就是说采取某种规则策略，将数据表横向切开。表数据达到百万级别，可以考虑。
  - 水平拆分表对于单机来讲，性能提升不大，最好是**水平分库**，但分片事务难解决，跨界点Join性能较差，逻辑复杂 。
  - 客户端代理和中间件代理？

#### 28.为什么用redis？为什么是redis？

提升并发访问性能。

相对于memcached，支持更多的数据类型。

redis可以将数据持久化，就是说可以把内存中的数据存到磁盘中，重启时可读取磁盘的数据。memcached不支持。

#### 29.redis数据类型有哪些？分别在哪些场景下使用比较合适？

String，Hash，List（双向链表），Set，Sorted Set

#### 30.redis常用指令？

set、get、hget、hset、lpush、rpush、lpop、rpop、lrange（可用于分页）

#### 31.如何设计redis的过期策略？

redis内存淘汰机制

针对已设置过期时间的数据集有几个策略：

volatile-LRU：最近最少使用原则

volatile-TTL：即将要过期的

volatile-Random：任意选择淘汰

……

#### 32.redis如何做持久化？

RDB（快照）：默认的持久化方式，复制快照的其他服务器

AOF（追加文件）：开启方式 `appendonly yes`

可设置的追加策略有三种：always每次写操作、everysec每秒钟、no让操作系统决定。一般选择**everysec**

#### 33.说一下缓存雪崩

缓存大面积失效，导致瞬间有大量请求打到数据库上，数据库承受不住崩掉了

处理方法：

事前：尽量保证缓存的高可用，集群啊，内存淘汰机制啊之类的

事中：也就是当缓存大面积失效时，打到请求量会激增，故要做好降级措施，比如有百分之40的请求会通过走向数据库，另外的百分之60的请求被降级，返回默认数据（提示语，空数据啥的）。

事后：备份恢复，尽快根据redis的持久化数据恢复。

#### 34.了解过分布式锁吗？

针对分布式场景下，对同一数据的写操作可能会导致数据错误，这时候可以使用分布式锁，对该数据加上锁（比较典型的是某件商品的库存）

redis与zookeeper

#### 35.怎么保证缓存与数据库的双写一致性？

cache aside pattern

读：读缓存，没有则从数据库找出，写入缓存

写：更新数据库后，删除缓存

**场景1：先update 数据库，再删缓存，如果删缓存失败了，数据不一致**

解决：先删缓存再删数据库

**场景2：先删缓存，后修改数据库，此时还没修改，第二个请求过来发现缓存没有，则去数据库拿数据并写到缓存，这时数据库还是旧数据，随后上一个请求走完了数据库更新完了，一样会出现数据不一致。**

解决：**数据库与缓存的更新与读取操作进行异步串行化**

更新数据时，根据数据的唯一标识（如商品的id），及一定的策略，将操作放到一个jvm内部的队列中；

读取时，如果发现缓存为空，则到数据库读取新数据并更新缓存，那么这一步也要根据唯一标识去路由到同一个队列中，排在上一个操作的后面，也就是所谓的“串行化”。

这里有一个优化点：假如这个队列中某一个写请求后，接连跟着十几个读操作，那么完全没有必要都放到队列里，后续的读直接等待，直到缓存里有值了直接取（也就是说前面的读操作进行了读数据库+缓存更新的操作），当放到队列里会不断执行读数据库+缓存更新的操作，完全一样的数据没有意义。

至于等待多久，根据实际项目要求的性能，设定等待时间。

**场景3：在场景2的基础上，如果部署了多台机器，那么同一个数据的读/写操作可能到了不同的机器上，数据也会不一致**

解决：自己写路由策略或者利用nginx，将同一数据（可以通过参数，比如请求中商品的id）的请求路由到同一台机器上。

**场景4：热点数据导致请求打到同一机器上，导致该机器压力过大**

其实到这个地步的话，个人觉得直接熔断算了，还是要根据实际情况，做各种压测，看看需不需要考虑进去。

#### 36.如果微服务网关每秒10万请求，该怎么优化？

1.看机器配置，比如部署在8核16g上，对网关路由转发的请求，每秒可以1000+，10台机器就是1w+

实际每秒10w不太多，实际情况要去做压测。



#### 37.说下spring

spring的出现主要是提高开发效率，提升系统的可维护性，她提供了一些模块和方案，像他的核心容器、web的像springmvc，aop，依赖注入，包括数据库的jdbc等等。

#### 38.谈谈对于Spring IOC和AOP的理解？

ioc称作控制反转，是一种设计思想，简单讲就是我们不用频繁的自己去创建对象，去考虑何时创建何时销毁，交给spring容器来控制，spring中通过xml来配置，springboot中则是以注解的方式来配置，简化开发。

IOC的初始化过程为：读取--解析--注册

AOP是面向切面编程，我们一般将一些通用的、与业务无关但又贯穿多个业务流程的逻辑抽离出来，做切面处理，比如权限、日志。AOP基于动态代理。

#### 39.SPring中单例bean的会有线程安全问题吗？

会有，但我们常用的 `Controller`、`Service`、`Dao` 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。

- 有状态是指：会涉及数据存储功能
- 无状态是指：不会保存数据。

dao层会操作数据库connection，spring事务管理器使用ThreadLocal为不同线程维护了一套独立的connection副本，线程之间不会互相影响。

#### 40.@Component和@Bean的区别？

前者作用域类，后者作用于方法。

Component是根据类类型去装配注册，后者是根据方法中定义的实例，把实例丢到了bean容器中。

#### 41.bean的生命周期是怎样的？

传统的spring来讲，

找到bean的定义-->解析-->执行bean构造器-->注入属性

-->调用init-method指定的初始化方法-->使用-->使用结束销毁

#### 42.了解SpringMVC吗？

M：model，对应到项目中的service、dao类和实体类这些

V：view，视图层，页面渲染

C：控制层，对应到controller

#### 43.SpringMVC工作原理（请求流程）？

前端请求过来后，先到dispatcherServlet

-->dispatcherServlet解析对应的handler （使用HandlerMapping）

-->解析后（解析的结果就是找到对应的controller），交给HandlerAdapter适配器处理

-->HandlerAdapter根据解析的结果调用controller处理

-->处理后得到一个ModelAndView

-->由ViewResolver解析ModelAndView找到对应的View视图（页面）

-->由DispatcherServlet解析得到Model交给View视图

-->View返回给客户端

#### 44.讲下mybatis缓存？

分一级缓存和二级缓存，默认一级缓存（放在session中），二级缓存需要另外配置开启，

对于一级缓存，同一个sqlSession对象，参数和sql完全一样的情况下，只执行一次sql（缓存没有过期的话）。可以在mapper文件中配置刷新缓存`flushCache=“true”`

#### 45.mybatis中#{}和${}区别

#{}可以防注入，预处理阶段会解析成？的形式，而${}会直接将值附上去。

#### 46.mybatis怎么实现延迟加载？

https://blog.csdn.net/eson_15/article/details/51668523?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control

开启配置项，定义resultMap其中使用association标签定义延迟加载的内容

原理：基于CGLIB的动态代理，以前看过详细流程记不清了

#### 47.mybatis有啥好处？

对于个人使用的感受就是，更灵活，sql掌控在自己手里，自己去编写sql，从ava代码抽离，不像jpa那样需要操作java对象，其实两者的选择看系统架构吧，以及是否有大量的复杂sql。

mybatis通过底层的映射自动转换成javabean 也不需要自己去编写转换

#### 48.mybatis接口绑定？

已经是开发必备的了，就是xml中配置对应到java接口的方法名，使接口映射到指定的mapper中去

#### 49.Mybatis的XML文件中，不同的XML映射文件，id可否重复？

看有没有配置命名空间了

#### 50.mybatis批处理

使用BatchExecutor

#### 51.mapper中如何传递多个参数？

方法参数前使用 @Param注解，xml中就可以直接用#{name}了。

#### 52.mybatis比ibatis改进在哪？

有接口绑定

#### 53.mybatis和ibatis的核心处理类是啥？

mybatis：sqlSession，Ibatis：记不清叫啥了

#### 54.事务的特性

ACID：原子性、一致性、隔离性、持久性

#### 55.事务隔离级别

读未提交：最低的隔离级别，会产生很多问题

读已提交：解决脏读

可重复读：解决脏读、不可重复读

可串行化：最高级别，遵循ACID，解决所有，但效率很低

#### 56.当要列举spring的功能的时候，可以列几个：

IOC、AOP、容器、事务管理

#### 57.切面有几种通知类型？

before、after Returning、after Throwing、After（finally）、Around

#### 58.静态代理与动态代理

代理模式的基本流程是，A类，自定义Proxy类都实现同一接口，代理类包含接口类型的成员变量，通过setter或构造器传入实现类。代理模式可以让你能将一些额外的操作抽离出来，而不是放在实际业务中，做到对这些额外的操作的修改不会对业务造成影响。比如你想跟踪实际业务方法的调用，可以写一个代理类去测试，而不是将测试需要额外编写的代码加到业务代码中去。

静态代理，编译时已确定代理关系。

动态代理，运行时通过反射+代理。

动态代理创建方式：`Proxy.newProxyInstance()`，参数包含一个从被加载的对象获取的类加载器`.getClass().getClassLoader()`、该类的接口列表`.getClass().getInterfaces()`以及`InvocationHandler`的一个实现。

> 动态代理可以将所有调用重定向到调用处理器，通常会向调用处理器的构造器传递给一个实际对象的引用。从而使得调用处理器在执行其中介任务时，可以将请求转发。

spring里也用了很多动态代理，比方说请求的处理，像feign，就是底层会针对接口生成动态代理，去做调用。还有mybatis的一些插件也用到了动态代理。

#### 59.mysql 锁的优化策略



#### 60.eureka底层原理

eureka中有一个服务注册表，利用了两级缓存（优化并发冲突）来维护，ReadWriteCache实时同步注册表的变动，ReadOnlyCache以一定的策略去从ReadWriteCache同步新的数据，而服务发现则是从ReadOnlyCache中去获取注册表数据。所谓的“策略”就是会有线程去做定时同步，定时时长可配置。

#### 61.feign是怎么个流程？

feign底层大致流程是，对接口使用了feign注解之后，他会针对这个注解标注的接口生成动态代理，然后我们针对feign的动态代理去调用他的方法的时候，底层会生成一个http协议的请求。底层使用http通信组件httpclient发送请求，发送之前，先通过ribbon去从本地的eureka注册表的缓存里获取出对方机器的列表，进行负载均衡选出一台机器来，对这台机器发送http请求。

#### 62.eureka服务注册发现慢怎么优化？

可以进行配置，两级缓存中，定是同步的时间间隔，服务注册的心跳间隔，服务发现的间隔等。参数记不清了。

#### 63.微服务网关的动态路由

通过可视化的界面把路径与服务的对应写到数据库库（db，redis，mongodb，甚至是文件）中，网关微服务定时去获取最新的路由信息，放到网关的路由表中去。

#### 64.灰度发布

通过数据库配置url是否启用灰度发布，写一个请求的过滤器，发现灰度开启了，就依据特定的逻辑去决定是否要请请求转发到新版本的服务上去。这里的逻辑可能是特定的用户群、特定的角色或是随机抽样一定的比例等等。

#### 65.一个服务开发到上线经历了些什么？

开发阶段，根据明确的需求，以及api文档，设计接口，开发，功能自测，对性能要求高的做压测，对可能会产生并发问题的做并发测试。发布时，对于新的服务，通过可视化页面配置动态路由，开启灰度发布，没问题后将新服务设置为正式版本（比如元数据中设置current标识为正式版本），关闭灰度发布。

#### 66.BIO、NIO、AIO有什么区别？

BIO：同步阻塞式IO，就是平常经常使用的IO

NIO：同步非阻塞式IO，通过channel，实现多路复用

AIO：NIO2，异步非阻塞IO，异步IO基于事件和回调机制

#### 67.Array和ArrayList有什么区别？

ArrayList不能放基本类型

ArrayList封装了更多方便的方法

#### 68.并行并发的区别？

并行是同一时刻多个进程同时跑，并发是同一时间间隔对**同一事物**的多个事件

#### 69.ThreadLocal是什么？有哪些应用场景？

用来解决多线程访问同一个共享变量时的并发问题

> ThreadLocal是jdk提供的，它提供了**线程本地变量**，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每一个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存。

也就是说，业务中必须要使用一个全局变量，而又会涉及多线程，则可以使用ThreadLocal。

spring中 在事务开始时会给当前线程绑定一个**jdbc connection**。整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。**这里的隔离性就使用了ThreadLocal**。

```java
public class ThreadLocalTest {
    static ThreadLocal<String> threadLocal = new ThreadLocal<>(){
        @Override
        protected String initialValue(){ return "initvalue"; }
    };
    public static void main(String[] args) {
        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                threadLocal.set("threadOne local");
                System.err.println("t1" + ": " +threadLocal.get());
            }
        });
        Thread threadTwo = new Thread(new Runnable() {
            @Override
            public void run() {
                threadLocal.set("threadTwo local");
                System.err.println("t2" + ": " +threadLocal.get());
            }
        });
        threadOne.start();// t1: threadOne local
        threadTwo.start();// t2: threadOne local
            Thread.sleep(2000);
        System.err.println(threadLocal.get());// initvalue
    }
}
```

#### 70.java内存模型

java内存模型规定，将所有的变量都放在主内存中，当线程使用变量时，会把主内存里的变量复制到自己的工作内存（cpu的一级缓存，或所有cpu共享的二级缓存，或cpu寄存器），线程读写变量时操作的是自己工作内存中的变量。

<img src="pictures\java内存模型.png">

#### 71.共享变量的内存可见性问题

双核cpu情景下，对于变量X，当两级缓存均空时，

线程A获取X发现没有则去主内存加载，更新到两级缓存中；

-->接着线程A执行X=1，将其写入两级缓存，并刷新主内存，此时两级缓存、主内存都是1

-->线程B获取X，一级缓存为空则去二级缓存获取，二级缓存命中了，更新到一级缓存；

-->线程B执行X=2，更新两级缓存，并刷新到主内存；

-->此时一切正常；

-->当线程A再次读取X时，对于A来讲，一级缓存不为空，X=1，直接返回。那么就有问题了，主内存明明是2才对。

这就是共享变量的内存不可见问题，**也就是变成B写入的值对线程A不可见**。

**而volatile可以保证可见性**，。

#### 72.synchronized的内存语义

进入synchronized的内存语义就是把再synchronized内使用到的变量从线程的工作内存中清除，这样synchronized块中使用到该变量时就不会从线程的工作内存中获取而是直接从主内存获取。退出synchronized块的内存语义是把再synchronized块内对共享变量的修改刷新到主内存。

**synchronized也可以保证共享变量内存的可见性，但会引起线程上下文切换，带来线程调度开销。**

#### 73.volatile可见性？

保证了内存可见性。

当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是把值刷新到主内存。其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存的值。

#### 74.volatile能保证原子性吗？

不能

#### 75.volatile场景？

写入变量不依赖变量的当前值时。假如依赖，那么会有获取+计算+写入的过程，这个过程不是原子性的。

读写变量时没有加锁。锁本身保证了内存可见性，这时不需要用volatile。

#### 76.可重入锁的原理？

内部维护了一个线程标识，表示该锁被那个线程占用，然后关联一个计数器，初始为0，。线程获取了锁，计数器+1，释放则-1。当获取了该锁的线程再次获取时发现线程标识是自己，计数器+1。

#### 77.redis有哪些功能？

数据缓存

分布式锁

消息队列

数据持久化

------

分割（主要为了打印排版）





















#### 78.怎么让线程顺序执行

场景1：线程池的单例方式Executors.newSingleThreadExecutor(); 因为是单例的，只有当前线程执行完毕被回收到线程池中时，则塞队列中的下一个任务才会进来。

场景2：主线程jion

场景3：线程内部join上一个线程

场景4：配合object的 wait方法和notify方法以及同步关键字synchronized使用。

场景5：使用ReentrantLock的 lock() unlock() 方法（待尝试）

场景6： 使用CountDownLatch（cd），构造函数中传入int，指定初始值（内部是一个基于AQS的sync），使用cd.countDown()方法对其进行倒计时，第二个线程内显示使用cd.await()方法，当这个sync减到0时，继续执行代码，不然线程一直等待。

场景7：使用**CyclicBarrier**，

场景8：信号量机制**Sephmore**，acquire()方法请求许可，release()方法释放持有的许可。

https://blog.csdn.net/sinat_41832255/article/details/101148319

#### 79.redis几个数据类型的应用场景

String：

hash：对象信息，登录信息等

list：关注列表等

#### 80.CAS原理

CAS即“compare and swap”，首先检查某块内存的值是否跟之前我读取时的一样，不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新的值设置给此内存。CAS具有原子性，原子性由CPU硬件指令实现保证，即使用JNI调用Native方法，调用硬件级别指令，JDK中提供了Unsafe类执行这些操作。

#### 81.jvm对java原生锁的优化？

java线程与操作系统的原生线程有映射关系，线程的阻塞或唤醒都需要操作系统协助，这就涉及用户态到内核态的转换。

自旋锁：线程阻塞前先自旋等待一段时间，可能在等待期间其他线程已经解锁，就无需让线程执行阻塞操作，避免用户态到内核态的切换。

偏向锁

轻量级锁

重量级锁

#### 82.补充12.synchronized与ReetrantLOck的区别

ReetrantLOck是Lock的实现类，互斥的同步锁

等待可中断

超时机制：过了一定的时间仍然无法获取则返回

可判断是否有线程在排队等待获取锁

可以相应中断请求：与synchronized不同，当获取到锁的线程被中断时能够相应中断，会抛出异常，并释放锁

可以实现公平锁



#### 83.java线程池原理？

看代码知道，它内部维护了一个HashSet，里面存放基于AQS实现的内部类Worker，而需要执行的任务放在阻塞队列 `BlockingQueue<Runnable> workQueue`  中。大致流程就是从这个队列中不断取出需要执行的任务，放到Workers中处理。



#### 84.线程池中的线程时怎么创建的？一开始就随着线程池的启动创建好的吗？为什么是先添加到队列而不是先创建非核心线程？

线程池默认初始化后不启动Worker，等待有请求时才启动。`execute()` 方法做了些啥？三个指标：

corePoolSize(核心线程数)、maximumPoolSize（最大线程数）、队列。

如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务。

大于或等于corePoolSize，则把任务放进等待队列。队列满了之后，创建非核心线程处理任务。如果已达到最大线程数了，线程池会抛出异常 `RejectExecutionException` 

进入execute方法能看到，实际上如果创建线程的过程会使用一个全局的悲观锁

```java
final ReentrantLock mainLock = this.mainLock;
```

如果不是先放进队列中去，而是在核心线程满载的情况下每次来都去创建，用完又立刻销毁，那么可能会造成频繁的获取锁与释放锁，频繁的线程创建销毁过程，这违背了线程池的初衷。

#### 85.ThreadLocal一定安全吗？（需要进一步加强理解）

内存泄漏问题。

ThreadLocal的实现基于一个ThreadLocalMap，Thread类中国有一个成员变量 `ThreadLocal.ThreadLocalMap threadLocals = null;` 存放全局变量的副本，

key为弱引用的ThreadLocal实例：

set方法：`private void set(ThreadLocal<?> key, Object value) `

弱引用就意味着，只要垃圾回收器工作了，那么他就会被回收，此时key就变为null了

内部entry类型：

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

value为线程变量的副本值。

**总之一定要自己去remove!!**

https://juejin.cn/post/6844904046373896205

#### 86.java引用类型

强引用：普通的引用声明，类似new这样的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象，需要回收则显示的将引用指向null

软引用：“还有用但并非必需的对象”。对于软引用指向的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出异常。

弱引用：垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

虚引用：“幽灵引用”“幻影引用”。

#### 87.设计模式

工厂模式：创建型模式，主要解决接口选择问题，当需要不同条件下创建不同实例时，实际需要哪个实例交给工厂去选择。

<img src="pictures\工厂模式.png" style="zoom:50%">

抽象工厂：定义一个抽象类，统一标准，可以有不同的工厂实现。

<img src="pictures\抽象工厂模式.png" style="zoom:50%">

单例模式：

懒汉：每次获取实例时判断实例是否为null

恶汉：直接 `private static Singleton instance = new Singleton();`，类加载就实例化，多线程安全。

建造者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。



------

分割（主要为了打印排版）



#### 88.数据库三大范式还是看一下吧，指不定就有面试官喜欢问很基础的东西。。

第一范式：字段原子性，不可再分。

第二范式：1的基础上，每行都要可以唯一区分开，其实就是主键。

第三范式：2的基础上，每个表都不包含其他表已经包含的非主键信息。（其实通常情况下，很多场景严格遵守第三范式的话，会有性能问题，比方说其实我只需要关联表的一个字段，却要去关联整个表来得到他。）



#### 89.集合框架--继承关系

<img src="pictures\Collection.jpg">

#### 90.集合框架--ArrayList、Vector、LinkedList异同

都实现了List接口，间接实现了Collection接口。

都是有序集合，允许重复。

Vector线程安全。其余no

ArrayList、Vector基于数组，有初始大小，容量不足动态扩充。LinkedList基于双向链表。

ArrayList、Vector继承了AbstracList抽象类，LinkedList继承了AbstractSequentList。

ArrayList、Vector实现了RandomAccess，这是一个空的接口，用了标识他们支持随机访问，而基于链表的LinkedList不支持随机访问。LinkedList实现了Deque--支持两端插入和删除的线性集合（双向队列）

#### 91.Map--继承关系

<img src="pictures\Map.jpg">

#### 91.Map--IdentityHashMap HashMap

IdentityHashMap是“引用比较”，HashMap是“对象比较”。

换句话说，IdentityHashMap中，当且仅当k1=k2时，判断k1与k2相等。HashMap中，判断相等的条件是

`k1==null ? k2==null : k1.equals(k2)`。

#### 92.HashMap的数据结构是“链表散列”，即数组+链表的结合体。

#### 93.hashMap put发生了什么

调用put方法时，首先计算key的hash值，然后把键值对放在集合中合适的索引上。如果key值（不是指哈希值）已经存在了，则value覆盖成新值。

#### 94.集合框架--List、Map、Set，存取元素时的特点

Set不允许重复（这里指的是两个元素equals）。**Set内部自动排序**

Set取元素的方式只能用Iterator接口遍历，没法直接去get某个元素。



#### 95.List的add(int index, E element)

List支持随机访问，也可以插入元素，插入位置如果有元素则该元素极其后面的元素都向后移动。

```
Inserts the specified element at the specified position in this list
* (optional operation).  Shifts the element currently at that position
* (if any) and any subsequent elements to the right (adds one to their
* indices).
```

#### 96.HashSet与TreeSet区别？

HashSet--哈希表，元素无序（指与插入顺序无关，内部会排序）。TreeSet--树结构，元素有序。

HashSet内部使用了HashMap的键来存储，保证了不可重复。



#### 97.sleep wait有什么区别？

sleep：当前线程主动让出cpu，cpu去执行其他线程，**但不会交出锁**，sleep过后，cpu会回到这个线程上继续往下执行。

wait：在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，让等待此锁的线程得到同步锁。当其他线程调用notify（）方法，刚才调用wait方法的线程就会解除wait状态并加入锁竞争，再次得到锁后继续向下执行。

notify不释放锁，而是告诉wait状态的线程可以去参与锁竞争，并不一定就马上能拿到锁。

#### 98.线程有几种状态？他们之间怎么转换的？

新建：new

就绪：start，等待os调度分配cpu；或从阻塞状态被唤醒（sleep结束，join的线程结束，等待用户完毕）

运行：获取cpu

阻塞：sleep；其他线程join()；试图得到一个已被占用的锁；等待某个触发条件（用户输入等）

死亡：线程运行结束；线程抛出异常；

<img src="pictures\线程状态转换.png">

#### 99.多线程中的忙循环是什么？

用空的循环让一个线程等待，使用这种方式替代sleep，不会交出cpu使用权，可以保留cpu缓存。

在多核系统中，一个线程醒来的时候可能会在另一个内核运行，这样会重建缓存。维乐避免重建缓存和减少等待重建的时间就可以使用忙循环。

#### 100.volatile原子性问题？

本身保证多线程场景下变量的可见性，volatile无法保证原子性。

java中除了long和double之外的所有基本类型的读和赋值都是原子性操作，而64位的long和double变量由于会被jvm当做两个分离的32位来进行操作，所以不具有原子性，会产生撕裂问题。但当定义long或double变量时，加上volatile，就具备原子性。

#### 101.阻塞队列？

内部使用了ReeTrantLock、Condition

- offer方法：尝试获取锁，得到后，其他入队出队操作的线程会阻塞并放入的lock锁的AQS阻塞队列。如果当前队列有空闲则走入队，满则返回false。

- enqueue()：尾部入队，offer中拿到锁后，队列没满就执行该方法，这里面会操作共享变量，而此前已经加了锁，所以内存可见，共享变量的值从主内存获取而不是cpu的一二级缓存。同时发送信号`notEmpty.signal()`激活条件队列里面一个因为`take()`方法而被阻塞的线程。

- put()：与offer不同的是，队列如果满了不是直接返回而是进入阻塞状态，放入`Condition`条件队列。`while (count == items.length) notFull.await(); ` 循环等待，直到队列有空闲并成功入队后返回true。

  await方法等待激活信号notFull.signal()。

- poll()：从队列头部获取并移除一个元素。没有则返回空。

- dequeue()：发送信号`notFull.signal()`激活条件队列里面一个因为`put()`方法而被阻塞的线程。

- take()：从队列头部获取并移除一个元素。与poll不同在于没有元素则阻塞而不是立即返回。

#### 102.讲一下生产者与消费者问题？如何实现？

生产者与消费者之间不直接通信，而是通过一个阻塞队列来通信。实现的基本逻辑就是，实现一个阻塞队列，提供一个锁机制，保证读写安全，提供一套信号机制（等待与唤醒），用来通知阻塞状态下的读写操作何时恢复。java的阻塞队列使用的是`ReenTrankLock+Condition`，最基础的可以用`synchronized锁+wait()+notifyAll()`。

#### 103.什么是原子操作？java中的原子操作是什么？

指执行一系列操作时，这些操作要么全部执行要么全部不执行。

java中synchronized或CAS可实现原子性

#### 104.怎么排查死锁？如何分析？（被问到再说，待看）

threaddump 工具。

#### 105.怎么运行一个线程？为什么调用start()会执行run()？为什么不直接调用run()。

传统start()方式或交给线程池去执行。

start()方法调用了 start0，是一个native方法，查看这个native方法的源码就知道它调用了&JVM_StartThread，也就是说虚拟机创建了一个本地线程，去执行线程的运行。如果直接调用run的话失去了线程的意义了，必须等待run执行完代码才能往下走。

#### 106.为什么innodb使用b-tree索引？和hash索引比较有什么优缺点？

- b-tree底层结构是多路平衡查找树，hash索引是类似hashmap的key-value的结构

- hash索引检索效率高，索引的检索可以一次定位，效率比btree高很多。

- 使用btree主要考虑hash索引的许多不利因素：
  - hash索引仅能满足等值查询，不能使用范围查询。
  - 对于组合索引，hash索引会对组合字段合并计算哈希值，所以查询条件是组合索引的真子集，无法命中索引，必须完全一致。
  - hash索引不能避免表扫描。
  - b-tree查询效率稳定

#### 107.b-tree索引怎么存的？

innodb里，b-tree叶子结点存储了**整行数据**的是主键索引，也是聚簇索引。而非聚簇索引存储的是主键的值，**索引的存储和数据的存储是分离的**。

#### 108.mysql5.6对索引做了哪些优化？

索引下推。减少回表次数。

不使用“索引下推”的话，引擎负责查找索引，完了交给mysql服务器判断是否符合具体的查询条件。

使用“索引下推”，引擎负责查找索引并且还根据条件判断是否符合。

#### 109.那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？

mysql中有个很重要的角色，就是查询优化器，并不是查询满足索引规则就一定会使用到索引，mysql查询优化器会判断是否真的有必要用到索引。

优化过程：

根据sql找出所有可能使用的索引；计算全表扫描的代价；计算使用不同索引执行查询的代价。选择代价最低的那个。

当然也可进行干预，比如使用 `force index`强制使用索引，或者 `ignore index`忽略索引等， 我们一般很少用。























------

分割（主要为了打印排版）



#### 110.为什么要序列化？序列化的场景？

序列化是指将java对象转换为字节序列的过程，通过实现Serializable接口实现（一般要配合io流去操作）。在网络传输、文件传输等场景下，可以保证传输内容不变，拿到之后可以通过反序列化完全恢复为原来的对象。

- 文本、图片、音频视频等媒体信息在网络上的传输依赖于二进制序列，这就需要借助序列化来实现在网络上的传输。

- 持久化：可以做到将对象保存到磁盘或数据库中。

#### 111.JVM运行时数据区包括哪些部分？

- 线程私有部分：
  - 程序计数器：**当前线程所执行的字节码的行号指示器**。循环、跳转等基础功能都需要计数器完成。
  - 虚拟机栈：虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时会创建一个**栈帧**，用于存储**局部变量表（基本数据类型、引用）**、操作数栈、**动态链接**、方法出口等信息。每一个方法从调用到执行完成都对应着一个栈帧在虚拟机栈中入栈出栈的过程。
  - 本地方法栈：为虚拟机使用到的**native方法**服务。

- 线程共享
  - 方法区：类信息、常量、静态变量、即时编译器编译后的代码。
    - 常量池：
  - 堆：存放对象实例。

#### 112.jvm怎么判断对象可回收

通过从根节点搜索引用链，没有找到则证明对象不可用可以被回收

#### 113.简单描述jvm出现的几种异常？

栈溢出：当前线程请求栈的深度超过当前java虚拟机栈的最大深度的时候，就抛出异常。

内存溢出：堆内存或永久代/元空间不够，无法分配对象或存放数据，同时堆空间或永久代/元空间无法再拓展。此外，垃圾回收期占用jvm98%资源同时回收率不到2%，也会内存溢出抛出异常。

#### 114.什么是程序计数器？为什么jvm需要它？

程序计数器记录当前线程正在执行的字节码的地址或行号。



#### 115.jvm中垃圾回收的算法有哪些？都有什么特点？

- 标记-清除算法：标记出需要回收的对象，标记完成后统一回收。
  - 效率低
  - 空间：标记清楚后会产生大量不连续的碎片
- 复制算法：将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去,然后再把使用的空间一次清理掉。
- 标记-整理算法：针对老年代的特点的一种标记算法。先标记，然后存活的对象向一端移动，然后直接清理掉其余的部分。

#### 116.HotSpt中的堆为什么要分为新生代和老年代？

根据不同年代的特点选择合适的垃圾收集算法

新生代：每次收集都会有大量对象四期--复制算法，只要付出少量的对象复制成本就可以完成垃圾收集。

老年代：存活几率相对高--没有额外的空间分配，不能使用复制算法，只能标记算法。

#### 117.类加载机制有哪几步？都做了些什么？

- 加载：
  - 通过一个类的全限定名获取定义此类的二进制字节流。
  - 将字节流锁代表的静态存储结构转化为方法区的运行时数据结构。
  - 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口
- 连接：
  - 验证：文件格式、元数据、字节码、符号引用。
  - 准备：类变量的初始值。这时候进行内存分配的仅包括类变量（static）
  - 解析：将常量池内的符号引用替换为直接引用
- 初始化
  - new、getstatic、putstatic、invokestatic。
  - 反射调用时
  - 子类初始化时，父类也要初始化

#### 118.双亲委派

加载类时，先判断是否已经加载，没有加载则去找父类加载器（父类加载器中会继续网上找），父类加载器也无法完成加载请求时，会走到**BootstrapClassLoader**，去尝试加载。

#### 119.具体如何对数据库垂直拆分或水平拆分？

- 垂直拆分：将访问频率高的字段放到一个表里去，将访问频率低的放到另一个表里去。数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能越好。

- 水平拆分：
  - 一般是根据实际业务场景选择合适的水平分表基准，就是要找到依据哪个字段取模，比如用户id，分到100个表中去，那就是用户id对100取模：user_id%100，结果就是具体第几张表。
  - uuid的话将uuid进行hash计算，获取到整数值，再进行取模操作。水平拆分更多的是进行分库而不是分表，因为分表实际上还是同一个数据库，容易受数据库io性能的影响。

#### 120.分库与分表同时实现策略？

１、中间变量　＝ user_id%（库数量*每个库的表数量）; 

２、库序号　＝　取整（中间变量／每个库的表数量）; 

３、表序号　＝　中间变量％每个库的表数量;

例如：数据库有256 个，每一个库中有1024个数据表，用户的user_id＝262145，按照上述的路由策略，可得：

```
１、中间变量　＝ 262145%（256*1024）= 1;
２、库序号　＝　取整（1／1024）= 0;
３、表序号　＝　1％1024 = 1;
```

这样的话，对于user_id＝262145，将被路由到第０个数据库的第１个表中。

#### 120.如何设计让系统从为分库分表动态切换到分库分表上？

在之前所有写库的复方，除了对老库的增删改，都加上对新库的增删改。

系统部署后，数据差异，用导数工具，读老库数据写新库，写的时候要判断数据最后的修改时间，除非是读出来的数据在新库里没有，或是比新库的数据新才会写。

导完后，数据仍有不一致，就比对每个表的数据，针对不一样的，从老库读数据再次写，直到完全一致。

最后基于分库分表的代码重新部署。

#### 121.如何设计动态扩容缩容的分库分表方案？

#### 122.有没有做过读写分离？如何实现？

搭建主从架构，主库负责写，从库负责读，主库自动把数据同步到从库。



#### 123.主从复制原理是什么？如何解决主从同步的延时问题

同步的方式采用binlog日志，从库拿到主库写好的binlog日志，写入中继日志。然后会有sql线程从中继日志去binlog，执行binlog的内容。

高并发场景下，从库的数据一定会比主库更新地慢一些。

排查有无延时，可使用 `show slave status` 查看。

解决：优化网络，硬件配置，并行复制。

#### 124.分库分表之后id主键如何处理

https://blog.csdn.net/lq18050010830/article/details/89845790

- 自增id的话，一个方法就是往一个无业务的表插入数据拿到自增的id，拿到之后在往分库分表中去写，但缺点是单库生成id，高并发会有瓶颈。或者专门开服务在代码层面去维护自增id。

- uuid能保持唯一，但长度32位，作为主键性能太差。而且uuid无序，会造成btree索引在写的时候有过多的随机写操作，频繁修改树结构，性能下降。
- snowflake雪花算法：是twitter开源的分布式id生成算法。核心思想是一个64位的long，且引入时间戳，具有自增性。
  - 64 个 bit 中，其中 **1 个 bit 是不用的**，统一是0，然后用其中的 **41 bit** 作为毫秒数，用 **10 bit** 作为工作机器 id，12 bit 作为序列号。
  - 12个bit用来记录同一毫秒内产生的不同id
  - 10bit中5个是机房id，5个是机器id，也就是说，最多可以支持32个机房，32台机器的数据。

#### 125.为什么StringBuilder比String快？

String是不可变的（final），每次拼接其实是新开辟了内存空间。而且“+”操作实际上调用了StringBBuilder的append方法。**假如有一万次+那么就有一万次的内存空间开辟**。

而StringBuilder内部维护了一个char[]数组，并且它是可扩容的，每次append操作其实是存到了char数组中，**真正用到的时候去申请内存空间**。

#### 126.StringBuffer/StringBuilder的append一定比+快吗？

一般情况下 **StringBuilder>String>StringBuffer**.

因为String用+连接时用到了StringBuilder，比StringBuffer是快的。

有一种情况下String是最快的，假如连接后的字符串在静态存储区中已经是存在的了，那么String+的效率是最高的。

如：

```java
 String string = "a" + "b" + "c";
```

> tip：静态存储区。常量、静态变量、全局变量，编译时期就分配好了。

#### 127.抽象类和接口有什么异同？

都不能直接实例化，但能定义引用。

抽象类中可以定义构造器，接口不能。

抽象类中的成员可以是所有的作用域类型，接口中都是public的。

抽象类可以有具体方法，接口不行（1.8之后可以了）

#### 128.线程池的拒绝策略

丢弃任务抛出异常

丢弃任务不抛出异常

丢弃队列最前面的任务，重新提交被拒绝的任务

由调用线程（提交任务的线程）直接执行此任务

#### 129.spring怎么解决循环依赖的？原理？

> 官网说明
>
> https://docs.spring.io/spring-framework/docs/5.3.10-SNAPSHOT/reference/html/core.html#beans-dependency-resolution

参考：https://www.jianshu.com/p/6cbbb6a9b3fd

spring内部通过三级缓存来解决循环依赖问题。

单例（singleton）的bean会通过三级缓存提前暴露来解决循环依赖问题。非单例的bean每次都是取新的对象，重新创建，非单例的bean没有缓存。

关键类：DefaultSingletonBeanRegistry。里面使用了三个map

<img src="pictures\springBean循环依赖-三级缓存.png">

一级：初始化好的bean（**可以直接用的**）

二级：早期实例化好的（**bean的<property>属性还没填充**）

三级：存放生成bean的工厂（**生成bean**）



几个重要方法：

- doCreateBean：创建bean的入口
- createBeanInstance：实例化bean
- addSingletonFactory：实例化好的bean添加到三级缓存，提前暴露
- populateBean：属性注入，这里会遇到循环依赖的问题
  - getSingleton：属性注入时，获取单例bean的方法，依次从一级二级三级缓存中去找
- initializeBean
  - addSingleton：加入1级缓存



doCreateBean()做了些什么？

1. 实例化bean：createBeanInstance（）
   1. 实例化bean后，为其创建了一个bean工厂，放到③级缓存中去。addSingletonFactory()中加3级删2级
   2. **提前暴露的是讲bean包装起来的工厂**
2. 填充属性：populateBean()
   1. 此时发现③级缓存中未发现B，就要创建B--**createBeanInstance**，B实例化bean的过程中，也去创建B的工厂，放在③级缓存中
   2. B填充属性时--**populateBean**，发现需要A，此时能在3级缓存中找到A，将A加②级删③级--getSingleton()。
   3. 这时B成功地注入了A,属性填充完毕，下一步去初始化**initializeBean**。
   4. B初始化完成后，是一个完整的Bean了，此时就加入①级缓存，删除②、③级缓存--addSingleton()。
   5. 最后A在①级缓存中拿到了B，注入成功进入下一步。
3. 初始化：initializeBean()
   1. 初始化完毕，A也放到了①级缓存

#### 130.大数据量导入导出方案

导出：

- 可以多个sheet
- 核心思想是分批查询写入excel。如果有自增的id，根据id去拆分。

- 很大了比如几百兆了，分多个文件打包
- 使用excel直接导出大数据，容易内存溢出，excel导出是将所有数据读取到内存中，而csv可以一行一行的写入（没试过，可能指的是直接从数据库查询数据并导出）





#### 131.定时器？分布式场景定时器怎么解决？一个挂了咋办？ 

- 基本方向：多个相同实例的相同定时任务，保证只有一个定时任务在执行。同时要有阻塞机制，单个节点执行任务时宕机，要能够让阻塞队列中的某一个实例拿到锁执行任务。再者要避免重复执行，可选方案有对同一个任务对应的数据库记录加行锁，或者结合分布式锁。

- 可选框架：
  - ShedLock：对公用数据库的记录和加锁。
    - 配合的注解：开启定时任务锁@EnableSchedulerLock，配置bean LockProvider，定时任务具体方法上的注解`@SchedulerLock(name="simpleTask",lockAtLeastFor = 1*1000)`
  - Quartz：也是结合数据库实现。
    - 基本流程：由SchedulerFactory创建Schedule调度器，由这个调度器去调取即将执行的trigger，找到对应的JobDetail信息，进而找的具体的job类去执行。
    - Quartz中主要有两种线程：执行线程与调度线程。调度线程个负责调度任务，加入有即将出发的trigger，则从线程池取出一个线程作为执行线程去执行trigger所对应的job。
  - Elastic Job：与zookeeper搭配使用



#### 132.Mybatisplus

- Mybatisplus是一款mybatis增强工具。
- 新增的特性：
  - CRUD：通用mapper，单表的CURD，条件构造器
  - 支持lambda
  - 分布式唯一id生成器Sequence：原理--
  - ActiveRecord模式：实体类继承model。
  - 内置插件：代码生成插件、分页插件、性能分析、全局拦截（自定义拦截规则，预防误操作）

#### 133.红黑树

- 二叉查找树（也叫二叉排序树、二分搜索树）：

  - 每个节点值比所有左子树节点大，比所有右子树节点小
  - 左右子树也是二叉排序树
  - 左右子树可空

- 平衡二叉树： 

  - 平衡因子：某个节点的左子树的高度-右子树的高度    就是这个节点的平很因子值。
  - 必要条件：
    - 是二叉排序树
    - 平衡因子的绝对值均<=1

- 平衡二叉树的自平衡：

  - 右旋：二叉树整体向左倾斜。

  <img src="pictures\二叉查找树1.png" style="zoom:50%">--右旋--<img src="pictures\二叉查找树右旋.png" style="zoom:50%">

  <img src="pictures\二叉查找树右旋2.jpg" style="zoom:60">

  

  - 左旋：二叉树整体倾向右侧。
  - 四种情况：
    - LL：插入的节点在左子树的左侧：找到平衡因子大于1的节点进行右旋转
    - RR：右子树的右侧：找到平衡因子大于1的节点进行左旋转
    - LR：左子树的右侧：先左旋转后右旋转
    - RL：右子树的左侧：先右旋转后左旋转
  - 什么时候维护平衡？

- 红黑树

  - 2-3树

    - 节点可以存放一个或两个元素，可以有最多可以有三个孩子

    - 2-3树是一颗绝对平衡的树--对于任意一个节点，左右子树的高度一定是相等的

    - 2-3树构建过程

      示例

      <img src="pictures\2-3树创建流程.png">

  - 红黑树与2-3树的关系

    <img src="pictures\2-3树与红黑树的关系.png">

  - 红黑树必要条件
  
    - 二分搜索树
    - 节点分为红色黑色
    - 根节点是黑色的
    - 每个叶子结点（null节点）是黑色的
    - 如果一个节点是红色的，那么他的孩子节点都是黑色的
    - 从任意一个节点到所有可到达的叶子结点，经过的黑色节点是一样的（对应的2-3树结构中，无论是2节点还是3节点都会有一个黑节点，2-树又是完美的二叉平衡树，所以走左子树或右子树经历的高度一样）
    
  - 严格意义上讲 不是平衡二叉树，  最大高度：**2logn**
  
  - 红黑树添加新元素以及左右旋转？



#### 134.乐观锁悲观锁

- 乐观锁：总是假设最好的情况，每次拿数据都认为别人不会修改，但会去判断这个数据有没有被修改。**乐观锁适用于多读场景**。

  - CAS方式（会有ABA等问题）和版本号机制
  - 缺点：ABA问题、循环时间唱开销大（）不停自旋

- 悲观锁：总是假设最坏的情况，每次拿数据时都会上锁，后面来的阻塞住。**共享资源每次只给一个线程使用**。

  **悲观锁适用于多写的场景**

  - 行锁表锁、synchronized、ReetrantLock



#### 135.工厂模式的好处？

可维护性高，假如有新的实现，可以直接替换，不用动到调用端



#### 136.spring怎么实现事务管理的？

编程式事务：在程序中自行控制事务的开始、提交或者回滚。

声明式事务：使用注解**@Transaction**，其原理是，spring会为其生成一个代理对象，当走到需要事务管理的方法时，由代理对象把当前session的事务提交方式改为false，再去执行业务逻辑，无异常则结束后commit，有异常则rollback。

#### 137.spring自动装配机制？

bean的定义中可以使用 `wutowire`属性，配置自动装配方式。

默认不自动装配

byName：根据名称

byType：根据类型。假如有多个同类型的bean需要使用`@qualifier`确定，或改用byName方式

constrcutor：byType是setter注入，constructor是构造器注入。

springboot中可以在启动类用注解生命的方式装配bean

#### 138.hashmap死循环问题？

hashMap扩容原理：

https://blog.csdn.net/lkforce/article/details/89521318

`TREEIFY_THRESHOLD`：**默认为8**，当链表节点数量大于该值时，**有可能**会转为红黑树

`MIN_TREEIFY_CAPACITY`：默认64。链表长度超了阈值，当数组table长度小于该值时，会触发扩容；当大于64时，会转红黑树。

jdk1.7扩容机制：扩容时采用头插法，新的链表与原链表是相反顺序的。多线程环境下，当T1想处理节点时，T2已经扩容了，链表已经逆序，T1再继续处理时，就可能会产生环形链表。

jdk1.8扩容机制：





#### 补充38.AOP

AOP基于动态代理，动态代理分jdk动态代理和cglib

jdk动态代理针对接口

cglib针对java类

#### 补充44.mybatis缓存

二级缓存：



135.redis

#### zookeeper选举机制



#### .为什么使用消息队列？

解耦

异步

削峰





#### MQ削峰



拉链法解决哈希冲突？（待看）

延时双删？

文件异步下载？

