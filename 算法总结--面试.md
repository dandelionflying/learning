#### 1.选择排序：

循环列表，每次把当前数组[i,arr.length]最小的找到，放到最前面，然后从当前最小的下一个(i++)开始新的循环，直到走到最后一个元素。

时间复杂度：O(n²)

#### 2.插入排序

每次循环把元素插入到已排好序的部分中去，会涉及多次交换元素的过程，直到整个数组都排序完成

时间复杂度：O(n²)

#### 3.归并排序

使用了递归的思想，将待排序数组的排序转化为子数组的排序。

时间复杂度：O(nlog2n)

#### 4.快速排序

每次从当前数组选择一个元素为基点，将其放到正确位置，排序的结果是，小于该元素的值在一侧，大于该元素的值在另一侧。

parition：几个参数，l代表最左侧，r代表最右侧，j标识小于基点值的且最后一个元素的索引，i一直往后遍历，当i位置的值小于基点值时，将其余j位置的值交换，扩充左侧，i继续往后遍历。最终将基准点的值与j交换。

可以通过基准点的选择优化算法。随机索引。

时间复杂度：O(nlog2n)

#### 5.双路快排

使用两个索引遍历，数组两侧同时进行

#### 6.三路快排

处理等于基准值的情况，把数组划分为三部分。

时间复杂度：O(n)

#### 7.二分查找

针对已排序的数组。

时间复杂度：O(log2n) 不算上排序

#### 8.二分搜索树

层序遍历

前中后序遍历

#### 7.桶排序

