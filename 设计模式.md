### 一、框架中用到的设计模式

#### 简单工厂：

BeanFactory。又一个工厂类根据传入的参数动态决定创建哪一个bean。

#### 工厂方法“

FactoryBean接口。

#### 单例模式

spring依赖注入的bean模式是单例的，getSingleton方法

Calender：获取Calender日期类示例的方式

#### 观察者模式

监听器

#### 代理模式

AOP底层：动态代理的实现

#### 装饰器模式

java的io流，比如BufferedReader 和BufferWriter，他们都通过装饰器模式的原理，增强了reader和Writer。

#### 适配器模式

SPringMVC中就有HandlerAdapter，根据不同handler规则执行不同的Handler







### 二、常见设计模式

#### 工厂模式：

创建型模式，主要解决接口选择问题，当需要不同条件下创建不同实例时，实际需要哪个实例交给工厂去选择。

**利用向上转型**

<img src="D:/ideaProject/learning/pictures/工厂模式.png" style="zoom:50%">

#### 抽象工厂：

定义一个抽象类，统一标准，可以有不同的工厂实现。运行同一套抽象接口规范有不同的实现，实现多个工厂应对不同需求。

<img src="D:/ideaProject/learning/pictures/抽象工厂模式.png" style="zoom:">

#### 单例模式：

懒汉：每次获取实例时判断实例是否为null，为空则去实例化对象

恶汉：直接 `private static Singleton instance = new Singleton();`，类加载就实例化，多线程安全。

#### 建造者模式：

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。



#### 代理模式

结构性模式。代理类与目标类实现同一个接口，代理类含有目标类类型的成员变量，代理类通过在接口实现方法中调用目标类的方式，实现代理。

<img src="pictures\设计模式-代理模式.png" style="zoom:10">

#### 观察者模式

行为型模式。个人的理解就是当某一个条件发生变化，观察者发现了变化进而去做执行一系列行为。

**被观察者里有一个 ArrayList 存放观察者们**

<img src="pictures\设计模式-观察者模式.png" style="">

#### 装饰器模式

结构型模式。和代理模式有点类似，区别在于装饰器模式侧重点在于不仅调用还进行拓展。

**动态地给一个对象添加一些额外的职责**

<img src="pictures\设计模式-装饰器模式.png" style="">

#### 模板模式

行为型模式。一个抽象类或接口定义了执行它的方法的模板，子类可以按需重写方法实现，但调用将以抽象类中定义的模板进行。

定义一个算法骨架，而将一些步骤延迟到子类中。模板方法可以使得子类可以重写逻辑但不改变算法结构。

**封装个不变部分，拓展可变部分**

基本方式：**模板方法使用final关键词，保证该“算法逻辑”不可改变**，如

<img src="pictures\设计模式-模板模式.png" style="">

#### 适配器模式？

