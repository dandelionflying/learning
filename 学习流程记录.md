## 2020年7月8日

结束c#基础学习（高级编程除外），开始u3d基础学习,b站香槟堡伯爵讲课过于拖沓，考虑更换视频
文字教程
http://c.biancheng.net/unity3d/
视频教程
慕课 https://www.imooc.com/learn/313

## 2020年7月9日

游戏开发学习进度：观看慕课u3d基础视频

## 2020年7月10日

微服务学习：阿里云大学视频 https://edu.aliyun.com/roadmap/microservice?spm=5176.13345299.1392477.2.4a83f153Rw9qM
## 2020年7月11日

微服务学习：继续视频，根据官方文档建立demo

## 2020年7月13日

微服务学习：初步认识了nacos服务发现，学习nacos分布式配置中心

## 2020年7月28日

日子一下子就过去了，此后一直没有继续学习
早上再早起二十分钟，七点二十出门，
早上花费的时间大致在35分钟左右，通勤40分钟，八点到公司的话，至少要在六点四十起床，那么起码八点-九点半之间可以自由学习

## 2020年7月29日

## **2020年8月03日**

改变计划，8月份先啃spring源码

## **2020年8月04日**

改变计划，8月份先啃spring源码或并发、优化、性能等相关问题

今日感兴趣的事情：搭建es集群+压测

https://mp.weixin.qq.com/s?__biz=MzI4Njk5OTg1MA==&mid=2247484933&idx=1&sn=fcb8f09f7a4af2ed7fe52a1b9b7e39ac&chksm=ebd51240dca29b56221fc615be8a80770258356ef0eabd0f92628b2bce659e91da486b87bd69&scene=126&sessionid=1596508924&key=4435c9834d0607a7acc2d66515a921cda9381565a0204513358159a0a68f206bf00840f3dfb2555ffea8c914885e4799268ea60ad465a489ece628569d393ba0e7c40c3715992a38bd590c21f58e0f2f&ascene=1&uin=MjMwMTEyMDg3NA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AW%2BwkuaE1FrQrTOZj%2Bd%2BA60%3D&pass_ticket=MlvmEJXP%2BET3u9eO3k8NG14fKtoq%2FteoGCiRHcezs5ihwT7enoU4rUFshktnDB%2FB

https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247491631&idx=2&sn=42537edb7cc04a7e4e60c5727ec348ac&chksm=eb506519dc27ec0ffd7a4e107063b6b2b1013aefd8ed7e97e359ae9a6144181fce8ff76c66ac&scene=21#wechat_redirect

## **2020年8月06日**

今日、疲惫。。。。。划水

## **2020年8月07日**

乱掉了。。。。。随缘学习吧

## **2020年8月13日**

近日：activiti

## **2020年8月14日**

## **看到的文章**

如何用 SpringBoot 实现并发登录人数控制（附代码）

[https://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247493102&idx=1&sn=28441e8e73619492d2273215f16f4afe&chksm=fc798840cb0e0156814ea37f9f6f82cdc0c0664e66d6f6d806fd37257a96d896ce1e6ca27f9d&scene=126&sessionid=1597309217&key=d346675dd6ecd6cce249b405bb9a90aa79b7c54f7c569368c928f8a0fba084157e2d5f8bcf520c432a62b78b75bcf34f637ffffec8103fe30ba90c88876a70ded60bb9c899a3c67f5ca58b254e3f8075&ascene=1&uin=MjMwMTEyMDg3NA%3](https://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247493102&idx=1&sn=28441e8e73619492d2273215f16f4afe&chksm=fc798840cb0e0156814ea37f9f6f82cdc0c0664e66d6f6d806fd37257a96d896ce1e6ca27f9d&scene=126&sessionid=1597309217&key=d346675dd6ecd6cce249b405bb9a90aa79b7c54f7c569368c928f8a0fba084157e2d5f8bcf520c432a62b78b75bcf34f637ffffec8103fe30ba90c88876a70ded60bb9c899a3c67f5ca58b254e3f8075&ascene=1&uin=MjMwMTEyMDg3NA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=ARCIMmczi34%2FUt%2BLRaSVoLc%3D&pass_ticket=t%2BgkW4A7OsLCDXILVKSMzwz8xeSaWFX3xaI%2FbssAZqhRTK%2BwqmE9Ja3V%2F1FpPdSK)


## **2020年8月20日**

谷粒商城2020列入计划，先处理原先的一些半途没做的东西吧。
## **2020年9月10日**
redissionClient。

## **2020年10月17日**

近期学习：

百度ai中图像识别与人脸识别的初探
进度：基础api了解完毕，正在申请离线采集SDK和离线识别SDK

### **（要注意的是，激活后只有三个月的有效期，不能浪费掉）**

模拟并发场景的分布式锁控制，进行了简单的jmeter测试

sentinel学习

## **2020年10月19日**

zookeeper应用场景、选举机制、数据模型

> https://www.bilibili.com/video/BV1JT4y1g7nM?p=28

开始大数据基础学习



## **2020年10月21日**

学习axios，但在尝试与vue整合是，发现建立新的完整的vue项目并不熟练，需要从建vue项目开始，包括路由配置等等

## **2020年10月22日**

- 近期观看黑马官方的大数据hadoop入门教程，感觉很多都只是照课件按部就班念，讲到一些指令，一些需要安装的软件，甚至没有提一下作用，并且教程使用的软件都比较旧，故停止观看。另觅。
- 需要整理一下网盘，快满了，去除意义不大的视频

## **2020年10月23日**

- Python入门学习，基本语法

## **2020年10月26日**

- hadoop环境搭建，不顺利，可能还没从周末缓过来，头脑不清楚

## **2020年10月27日**

- gogs环境搭建--ssh方式连接失败，寻找原因



## **2020年10月28日**

- gogs搁置（ssh方式多分支），回自己的电脑上试
- hadoop环境搭建
- hadoop集群搭建
- 搭了一天的环境

## **2020年10月29日**

- hadoop集群搭建成功
- 学习hdfs

## **2020年10月30日**

- 学习hdfs

## **2020年10月31日**

- 学习hdfs 文件操作
- 周末：整理一下网盘、游戏开发、月末总结

## **2020年11月03日**

- 学习MapReduce



## **2020年11月05日**

- springboot构建电商秒杀基础项目 项目搭建  配置mybatis自动生成工具遇到一些问题
- 明日：下载慕课网友提供的代码调通，检查合理性，把重点放在秒杀设计和优化上。

## **2020年11月06日**

- springboot构建电商秒杀基础项目搭建完成，github push速度过慢，需要寻找有效的解决方法

## 2020年11月11日

- springboot秒杀项目
  - 页面调整
  - 图片显示
  - 静态资源处理

## 2020年11月12日

- springboot秒杀项目
  - 并发容量问题
    - tomcat连接数、最大等待队列数量、最大线程数配置

## 2020年11月13日

- 解决虚拟机网络突然不通的问题

  - 可能原因：

  之前装过virtualbox，后来卸掉了，可能网络有冲突

  将VMnet1禁掉后，成功ping通

  解决虚拟机网络突然不通的问题

- springboot秒杀项目

  - 分布式扩展

    - 单机容量问题--水平拓展

      将应用部署在多台服务器上

    - nginx安装（openResty）

      1. 前置条件

         `yum install pcre-devel openssl-devel gcc curl`

      2. 解压

      3. 初始化配置

         `./configure`

         `gmake`

         `gmake install`

         结果路径：

         /usr/local/openresty

      4. 启动

         `sbin/nginx -c conf/nginx.conf `

## 2020年11月15日

- 解决centos下，设置静态ip后，与宿主机ping通但与外部网络无法ping通（以百度为例）

  - 虚拟机网络设置中，对于VMnet8，不要勾选“使用本地DHCP服务将ip分配给虚拟机”
  - 确定宿主机的dns服务器设置
  - 在虚拟机中，将网关设置为 vm虚拟网络配置中“net设置“中设置的网关
  - 在虚拟机中，设置dns1，值为宿主机中设置dns服务器地址
  - 若出现虚拟机可ping通宿主机和外部网络，但宿主机无法ping通虚拟机网络，则需要检查网络适配器中`VMware Virtual Ethernet Adapter for VMnet8`的配置，手动配置网关等

- mysql授权远程连接

`grant all privileges on *.* to root@'%' identified by 'dandelion';`

将所有的权限授权给从任何ip登录的root用户，并需要验证密码

“%”可替换为允许连接的某个ip

验证：

`select host,user,password from user;`

- springboot秒杀项目
  
- deploy方式启动
  
  - 创建deploy.sh
  
  
  
    ```shell
    nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m  -jar demo-0.0.1-SNAPSHOT.jar  --spring.config.addition-location=/my/projects/application.properties
    ```
  
    
  
    - 运行
  
    
  
    ```
    ./deploy.sh
    ```
  
    
  
    - 查看运行日志
  
  ```
  tail -200f nohup.out
  ```
  

  
  - 分布式扩展
  
    - nginx反向代理配置，实现动静分离
  
      配置样例：
  
          upstream backend_server{
                  server pc-3 weight=1;
                  server pc-4 weight=1;
              }
          server {
              listen       80;
              server_name  localhost;
              #charset koi8-r;
          
              #access_log  logs/host.access.log  main;
          
              location /resources/ {
                  alias  /usr/local/openresty/nginx/html/;
                  index  index.html index.htm;
              }
              location / {
                  proxy_pass http://backend_server;
                  proxy_set_header Host $http_host:$proxy_port;
                  proxy_set_header X-Real-Ip $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              }
              ······
          }
  
- - **实测结果（线程数：1000，循环次数10）**：

单机(url:http://192.168.80.133/user/getUser?id=5)：

| Label    | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量    | 接收 KB/sec | 发送 KB/sec |
| -------- | ------ | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | --------- | ----------- | ----------- |
| HTTP请求 | 10000  | 745    | 712    | 916        | 1424       | 10257      | 1      | 11071  | 0.00%  | 789.82703 | 245.28      | 0           |

负载均衡(url:http://192.168.80.131/user/getUser?id=5)：

| Label    | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量    | 接收 KB/sec | 发送 KB/sec |
| -------- | ------ | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | --------- | ----------- | ----------- |
| HTTP请求 | 10000  | 363    | 105    | 862        | 1188       | 6217       | 1      | 6606   | 25.66% | 1116.5699 | 1007.98     | 0           |





- **nginx设置与后端服务器之间建立的连接为长连接(按教程上讲是为了减少短连接创建关闭的资源消耗,未测试)**

  - 默认的http协议为1.0，将http协议改为1.1，并且将连接策略“proxy_set_header Connection”置空

  - 配置样例：

        upstream backend_server{
                server pc-3 weight=1;
                server pc-4 weight=1;
                keepalive 30
            }
        server {
            listen       80;
            server_name  localhost;
            #charset koi8-r;
        
            #access_log  logs/host.access.log  main;
        
            location /resources/ {
                alias  /usr/local/openresty/nginx/html/;
                index  index.html index.htm;
            }
            location / {
                proxy_pass http://backend_server;
                proxy_set_header Host $http_host:$proxy_port;
                proxy_set_header X-Real-Ip $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_http_version 1.1;
                proxy_set_header Connection "";
            }
            ······
        }

    

## 2020年11月16日

- jfinal全局异常拦截处理

## 2020年11月17日

- 分布式扩展

  - 分布式会话

    - springboot+springsession+redis

      **遇到的问题**

      写入session，随即输出，有值

      再次请求获取，null，疑是跨域问题

      同域测试正常

      `@RequestMapping("redisTest") @ResponseBody public Object redisTest(HttpServletRequest request){    request.getSession().setAttribute("request Url",request.getRequestURL());    return request.getRequestURL(); } @RequestMapping("getRedis") @ResponseBody public Object getRedis(HttpServletRequest request){    return request.getSession().getAttribute("request Url"); }`

      

      `org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'enableRedisKeyspaceNotificationsInitializer' defined in class path resource [org/springframework/session/data/redis/config/annotation/web/http/RedisHttpSessionConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.data.redis.RedisConnectionFailureException: Unable to connect to Redis; nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.80.132:6379`

    DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.

    翻译：

    拒绝的Redis正在保护模式下运行，因为已启用保护模式，未指定绑定地址，未向客户端请求身份验证密码。在此模式下，只接受来自环回接口的连接。如果您想从外部计算机连接到Redis，您可以采用以下解决方案之一：1）只需禁用保护模式，通过从服务器运行的同一主机连接到Redis，从环回接口发送命令“CONFIG SET protected mode no”；但是，如果您这样做吧。使用CONFIG REWRITE使此更改永久化。2） 或者，您可以通过编辑Redis配置文件并将protected mode选项设置为“no”，然后重新启动服务器来禁用保护模式。3） 如果您只是为了测试而手动启动服务器，请使用“-protected mode no”选项重新启动服务器。4） 设置绑定地址或身份验证密码。注意：您只需执行上述操作之一，服务器就可以开始接受来自外部的连接。

    

    **尝试修改：将redis.conf文件中protected-mode设置为no，禁用保护模式即可**

    - 

    

## 2020年11月18日

- springboot秒杀项目

  - 分布式扩展

    - 分布式会话

      - 基于token

        localStorage+redis+token

  - 查询缓存优化

    - redis查询缓存基础用法
      - redisTemplate
      - 自定义RedisTemplate

```java
package cn.running4light.demo.config;

import cn.running4light.demo.serializer.JodaDateTimeJsonDeSerializer;
import cn.running4light.demo.serializer.JodaDateTimeJsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import com.fasterxml.jackson.databind.module.SimpleModule;
import org.joda.time.DateTime;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.stereotype.Component;

/**
 *
 */
@Component
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
public class RedisConfig {
    // 定制化redisTemplate
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        // 设置key序列化方式--string形式
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringRedisSerializer);
        // 设置value序列化方式
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        // redis：扩充特殊对象的字符转换
        ObjectMapper objectMapper = new ObjectMapper();
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(DateTime.class,new JodaDateTimeJsonSerializer());
        simpleModule.addDeserializer(DateTime.class,new JodaDateTimeJsonDeSerializer());

//        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,ObjectMapper.DefaultTyping.NON_FINAL);// 不完全懂基础作用
        objectMapper.registerModule(simpleModule);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);

        return redisTemplate;
    }
}
```





- 本地热点缓存

  - guava cache

  

  - 依赖

  ```
          <dependency>
              <groupId>com.google.guava</groupId>
              <artifactId>guava</artifactId>
              <version>23.0</version>
          </dependency>
  ```

  

  - 封装

  ```java
  import cn.running4light.demo.service.CacheService;
  import com.google.common.cache.Cache;
  import com.google.common.cache.CacheBuilder;
  import org.springframework.stereotype.Service;
  
  import javax.annotation.PostConstruct;
  import java.util.concurrent.TimeUnit;
  
  @Service
  public class CacheServiceImpl implements CacheService {
  
      private Cache<String, Object> commonCache;
  
      // bean加载时优先执行
      @PostConstruct
      public void init() {
          commonCache = CacheBuilder.newBuilder()
                  // 初始化容量
                  .initialCapacity(10)
                  // 设置缓存中最大可以存储的key值数量，超过后会按照LRU的策略移除缓存项
                  .maximumSize(100)
                  // 写入缓存后的过期时间（本地热点缓存生命周期需要比redis短很多）
                  .expireAfterWrite(30, TimeUnit.SECONDS).build();
      }
  
      @Override
      public void setCommonCache(String key, Object value) {
          this.commonCache.put(key, value);
      }
  
      @Override
      public Object getFormCommonCache(String key) {
          return this.commonCache.getIfPresent(key);
      }
  }
  ```

  

  - 使用

  ```java
      public CommonResult getItem(@RequestParam(name = "id") Integer id) {
          // 取本地热点缓存
          ItemModel itemModel = (ItemModel) cacheService.getFormCommonCache("item_" + id);
          System.err.println("本地热点缓存：\t"+itemModel);
          if (itemModel == null) {
              // 取redis缓存
              itemModel = (ItemModel) redisTemplate.opsForValue().get("item_" + id);
              System.err.println("redis缓存：\t"+itemModel);
              if (itemModel == null) {
                  // 取数据库数据
                  itemModel = itemService.getItemById(id);
                  System.err.println("数据库：\t"+itemModel);
                  redisTemplate.opsForValue().set("item_" + id, itemModel);
                  redisTemplate.expire("item_" + id, 50, TimeUnit.SECONDS);// 5秒过期时间
              }
              cacheService.setCommonCache("item_" + id, itemModel);// 更新本地热点缓存
          }
          ItemVO itemVO = convertFromItemModel(itemModel);
          return CommonResult.create(itemVO);
      }
  ```

  

  - 压测：（**未测**）

  

  

  - 缺点：
    - jvm内存资源
    - 数据变动的更新策略

## 2020年11月19日

- springboot秒杀项目

  - 

  - nginx proxy cache

    - 配置

      nginx.conf

      ```properties
      #申明一个cache缓存节点的内容(配置nginx proxy cache)
      proxy_cache_path /usr/local/openresty/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g;
       #(配置nginx proxy cache)start
       proxy_cache tmp_cache;
       proxy_cache_key $uri;
       proxy_cache_valid 200 206 304 302 7d;
       #(配置nginx proxy cache)end
      ```

      

    - 压测(url:192.168.80.131:/item/get?id=6)

    | Label    | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量     | 接收 KB/sec | 发送 KB/sec |
    | -------- | ------ | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | ---------- | ----------- | ----------- |
    | HTTP请求 | 100000 | 0      | 0      | 1          | 2          | 7          | 0      | 132    | 0.00%  | 3349.85931 | 1867.79     | 0           |
    | 总体     | 100000 | 0      | 0      | 1          | 2          | 7          | 0      | 132    | 0.00%  | 3349.85931 | 1867.79     | 0           |

    实验结果为较极端情况（**缓存失效时间设置为7天**），实际很短

  - nginx lua

    - 简介

      - 协程机制

        依附于线程的内存模型，切换开销小

        与阻塞归还执行权，代码同步

        无需加锁

      - lua协程机制

      - nginx协程机制

        - nginx每个工作进程创建一个lua虚拟机
        - 工作进程内的所有协程共享一个vm
        - 每个外部请求由一个lua协程处理，之间数据隔离
        - lua代码调用io等异步接口时，协程被挂起，
        - 自动保存，不阻塞工作进程
        - io异步操作完成后还原协程上下文，代码继续执行
        - 处理阶段
          - 

      - nginx lua插载点

      - openresty

    - 实战

      - init_by_lua_file

      ```nginx
      #lua配置start
      #通过init.lua启动
      init_by_lua_file init_by_lua_file /usr/local/openresty/lua/init.lua;
      #lua配置end
      ```

      

      - content_by_lua_file(内容输出节点)

        

        ```nginx
        location /itemByLua {
                        content_by_lua_file /usr/local/openresty/lua/itemByLua.lua;
                }
        
        ```

        ```lua
        ngx.exec("/item/get?id=6")
        ```

        > http://192.168.80.131/itemByLua

      - 

      - lua_shared_dict

        

      - 

      - openresty对redis 的支持

        - 请求先通过nginx走redis查询，有值结束，无值走web应用接口

          请求-->nginx-->redis-->web接口-->本地热点数据-->redis-->数据库

        - lua

          ```lua
          local args = ngx.req.get_uri_args()
          local id = args["id"]
          local redis = require "resty.redis"
          local cache = redis:new()
          local ok,err = cache:connect("pc-2",6379)
          cache:select(10)
          local item_model = cache:get("item_"..id)
          if item_model == ngx.null or item_model == nil then
                  local resp = ngx.location.capture("/item/get?id="..id)
                  item_model = resp.body
          end
          ngx.say(item_model)
          ```

          

        - nginx

          ```nginx
          location /itemByNginxRedis/get {
          	default_type "application/json";
          	content_by_lua_file /usr/local/openresty/lua/itemByNginxRedis.lua;
          }
          ```

          url

          > http://192.168.80.131/itemByNginxRedis?id=6

        - 不生效解决：

          lua中每次获取到的缓存为 nullnil

          猜测：没有指定索引

          补充索引选择：

          cache:select(10)

          **不知道怎么切换，网上没找到方法，待处理**

      - 

      - 


## 2020年11月20日

- 

- 页面静态化

  暂时跳过

- 交易性能优化

  - 性能瓶颈
    - 库存行锁
    - 交易验证万全依赖数据库
      - 用户风控策略优化
      - 活动校验策略优化
      - 

- 

- 

